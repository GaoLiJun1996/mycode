# 408  复习笔记

## 时间复杂度

### 加法原理  和乘法原理

**注意乘法原理 不能直接使用，一定要判断内层循环和外层循环是否独立；如果独立，才能够相乘。**

#### 2022 统考真题   下列程序段的时间复杂度是

![image-20240916154446425](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916154446425.png)

答案：  选B

不妨设m为 满足`i=2^m^<n` 的 的最大的那个m， `m≈log~2~ n`
$$
sum = 1+2+4+...+2^{m-1} = 2^m-1 = 2^{log_2 n}-1
$$
因此时间复杂度为O(n).

## 栈 &队列

栈    先进后出

#### 2022 统考真题  给定有限符号集S，in和out均为S中所有元素的任意排列。对于初始为空的栈ST，下列叙述中，正确的是()。

#### ![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-16%20160136.png)

答案： 选D

入栈顺序可以跟出栈顺序一致：考虑ABCD四个元素，A~in~、A~out~  B~in~、B~out~、C~in~、C~out~、D~in~、D~out~   C选项错误

入栈顺序跟出栈顺序刚好相反，ABCD 全部入栈，再全部出栈。  D选项正确

> 栈的数学性质：n个不同元素入栈，出栈元素不同排列个数为$\frac{1}{n+1}\binom{n}{2n}$ ,称之为卡特兰数

根据上述性质卡特兰数 说明，排列是有限的，一定是可以判断是否是可能的出栈序列



## 二叉树的遍历

前序遍历、中序遍历、后序遍历

层序遍历

#### 2022 统考真题 若结点p与q在二叉树T的中序遍历序列中相邻,且p在q之前,则下列p与q的关系中,不可能的是( )。

![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img408202203.png)

观察中序遍历  左根右    兄弟节点不会挨着的，选B。



## 三叉树

### 2022 统考真题 若三叉树T中有244个结点(叶结点的高度为1),则T的高度至少是()。

![image-20240916163632467](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916163632467.png)

C。

【解析】:推荐思路2

思路1：设度为k的树T有n个结点, T的最小高度为$log_k(n(k-1)+1)$,得到T的最小高度是6。

思路2： 完全三叉树，1+3+9+27+81<244,  还需要一层，



## 哈夫曼编码

#### 2022 统考真题 对任意给定的含n(n>2)个字符的有限集S,用二叉树表示S的哈夫曼编码集和定长编码集, 分别得到二叉树T1和T2。下列叙述中,正确的是()。

![image-20240916163919595](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916163919595.png)

【解析】：答案选D   送分题，搞清楚哈夫曼编码是什么就可以。

为什么要有**哈夫曼编码**？

通过根据字符出现的频率来分配不同长度的编码，达到数据压缩的目的。具体来说，对于出现频率较高的字符，分配较短的编码，而对于出现频率较低的字符，分配较长的编码。这样可以在整体上减少编码后的数据长度，从而提升传输和存储的效率。

**定长编码**是一种为每个字符或符号分配相同长度的二进制编码的方法。无论字符出现的频率高低，每个字符的编码长度都是一致的。定长编码的优点是简单且容易实现，编码和解码都非常直接。



## 图的连通性

> 图的一些基本概念
>
> 1. 数据结构中仅讨论简单图， 满足以下两个条件的称之为简单图 
>
>     a.  不存在重复边
>
>     b.   不存在顶点到自身的边
>
> 2.  无向图 |E| 的取值范围 为$0到\frac{n(n-1)}{2}$ 
>
> 3.  有$\frac{n(n-1)}{2}$ 条边的 无向图  是无向完全图
>
> 4.  有向图 |E| 的取值范围 为$n(n-1)$ ，有$n(n-1)$ 条边的 有向图  是有向完全图
>
> 5. 无向图有n个顶点， 如果边数小于$n-1$,那么此图是非连通图；
>
> 6. 非连通图至多有$\frac{(n-1)(n-2)}{2}$边, 考虑  一个 有着$n-1$顶点无向完全图，再加上一个孤立的点就是非连通图。
>
> 7. **强连通图（强连通分量）**: 在有向图中，若每对顶点 u 和 v 都存在从 u 到 v 的路径，并且从 v 到 u 也存在路径，则称该有向图是强连通的。换句话说，图中的任意两个顶点都可以通过有向边互相到达。
>
>    **强连通分量**: 是强连通图的一个子图，其中的每一对顶点之间都可以相互到达。每个有向图的强连通分量是其顶点集的一个子集，并且子图本身也是强连通的。整个图可以被分解为多个强连通分量。

### 2022 对于无向图G=(V,E),下列选项中,正确的是()。

![image-20240916171740341](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916171740341.png)

答案选 D，

A 选项，考虑：一个 有着$n-1$顶点无向完全图，再加上一个孤立的点就是非连通图，边数满足 |V|> |E| 同样可能非连通图

B 选项：  |V| <|E|     边为1，3个顶点，没有办法连通

C选项： 无向图构成一个环即可成为一个连通图

D选项，无向图有n个顶点， 如果边数小于$n-1$,那么此图是非连通图；

## AOE

## B树 B+树



### B 树的概念和性质

#### 什么是B 树

1. 多路平衡查找树，注意 B 树是平衡的，所有结点的平衡因子均等于0.
2. 树中每个结点至多有m棵子树，也就是说之多有m-1 个关键字。
3. 若根结点不是叶子结点，则至少有两棵子树
4. 除根结点外的所有非叶结点至少有$\lceil \frac{m}{2} \rceil$ 棵子树，也就是说  至少有$\lceil \frac{m}{2} \rceil-1$ 个关键字。
5. 所有的非叶子结点，其中的关键字K~i~，同一层内有序，满足$K_1 < K_2 < K_3<...<K_n$ 
6. 所有的叶子结点都在同一层次，并且不带任何信息，可以视为查找失败的结点。

#### B 树的高度

B树的高度，

最矮 ====》要使每个结点尽可能的满 》 每个结点最多有m棵子树，m-1 个关键字

$高度为m B树: n\leq (m-1)(1+m^2+m^3+...+m^{h-1} = m^h$-1

====> **$h\geq log_m (n+1)$**



最高 ====》要使每个结点关键字尽可能的少 》

让各层的分叉尽可能的少,即根节点只有2个分叉,其他结点只有[m/2]个分叉
各层结点至少有: 第一层 1、第二层 2、第三层$2\lceil \frac{m}{2} \rceil$…. 第h层$2\lceil \frac{m}{2} \rceil^{h-2}$
第h+1层共有叶子结点(失败结点) 第h+1层:$2\lceil \frac{m}{2} \rceil^{h-1}$个
n个关键字的B树必有n+1个叶子结点,则 $n+1 \geq 2\lceil \frac{m}{2} \rceil^{h-1}$

最后 **$h\leq log_{\lceil\frac{m}{2} \rceil}(\frac{n+1}{2})+1$**

### B 树的插入

**B 树（B-Tree）的插入**是一种保持树平衡的操作，它在插入新键时通过调整树的结构来维持其平衡和节点的容量约束。B 树是一种自平衡的多路搜索树，广泛应用于数据库和文件系统中，用来高效地存储和检索数据。

**B 树的基本性质：**

- 每个节点可以包含多个键。
- 每个内部节点有 k+1 个子节点（若有 k 个键）。
- 所有的叶节点在同一层，树始终保持平衡。
- 节点的键数有上下限（通常称为 **最小度数 t**），每个节点至少包含 t−1 个键，最多包含 2t−1 个键。

**B树的插入过程**

1. **从根节点开始**： 插入从根节点开始。沿着路径查找要插入的位置。根据要插入的键，找到合适的子节点递归进行插入，直到找到叶节点为止。
2. **节点不满的情况**： 如果要插入的叶节点不满（即包含少于 2t−1 个键），则直接将键插入该节点。插入完成。
3. **节点满的情况**： 如果叶节点满了（即已经有 2t−1 个键），则需要将节点分裂。分裂的步骤如下：
   1. 将满节点分成两个节点，每个节点包含 t−1 个键。
   2. 将中间键（第 t 个键）提升到父节点。
   3. 如果父节点也满了，则递归执行分裂操作，直到找到不满的父节点，或分裂一直递归到根节点。
4. **根节点分裂**： 如果根节点满了（包含 2t−1 个键），则根节点也会进行分裂。原来的根节点分裂为两个子节点，新的根节点只包含一个键（从旧根节点中间位置提升上来的键）。这会导致树的高度增加。

### B 树的删除

![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img1700656535900.png)

![image-20240916222554441](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916222554441.png)

### 2022 统考真题   在下图所示的5阶B树T中,删除关键字260之后需要进行必要的调整,得到新的B树T1。下
列选项中,不可能是T1根结点中关键字序列的是()。

#### ![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img408202208.png)

答案选D   90和110 之间只有一个100， 不满足B 树的定义，关键字个数小于2.

## hash

比较简单，没什么意思。2024年 考大题，今年25肯定不会出大题。

## 排序

### 归并排序

####  总结

![image-20240916235416786](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916235416786.png)

#### 代码实现

```c
int *B=(int *)malloc(n*sizeof(int));//辅助数组B

//A[low ... mid]和A[mid+1 ... high]各自有序,将两个部分归并
void Merge(int A[],int low, int mid, int high) 
{
    int i,j,k;
    for(k=low; k <= high; k++)
        B[k]=A[k];
    
    for(i=low,j=mid+1,k=i; i <= mid && j <= high; k++)
    {
        if(B[i] <= B[j])
            A[k]=B[i++];
        else
            A[k]=B[j++];
    }
	while(i <= mid)
    	A[k++]=B[i++];
    while(j <= high)
    	A[k++]=B[j++];

} 

void MergeSort(int A[],int low, int high) {
    if(low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid+1, high); //对右半部分归并排序
        Merge(A, low, mid, high);  //归并
    } 
}

```



### 直接插入排序

### 快速排序

