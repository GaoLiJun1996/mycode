# 408  复习笔记

## 时间复杂度

### 加法原理  和乘法原理

**注意乘法原理 不能直接使用，一定要判断内层循环和外层循环是否独立；如果独立，才能够相乘。**

#### 2022 统考真题   下列程序段的时间复杂度是

![image-20240916154446425](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916154446425.png)

答案：  选B

不妨设m为 满足`i=2^m^<n` 的 的最大的那个m， `m≈log~2~ n`
$$
sum = 1+2+4+...+2^{m-1} = 2^m-1 = 2^{log_2 n}-1
$$
因此时间复杂度为O(n).

## 栈 &队列

栈    先进后出

#### 2022 统考真题  给定有限符号集S，in和out均为S中所有元素的任意排列。对于初始为空的栈ST，下列叙述中，正确的是()。

#### ![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-16%20160136.png)

答案： 选D

入栈顺序可以跟出栈顺序一致：考虑ABCD四个元素，A~in~、A~out~  B~in~、B~out~、C~in~、C~out~、D~in~、D~out~   C选项错误

入栈顺序跟出栈顺序刚好相反，ABCD 全部入栈，再全部出栈。  D选项正确

> 栈的数学性质：n个不同元素入栈，出栈元素不同排列个数为$\frac{1}{n+1}\binom{n}{2n}$ ,称之为卡特兰数

根据上述性质卡特兰数 说明，排列是有限的，一定是可以判断是否是可能的出栈序列



## 二叉树的遍历

前序遍历、中序遍历、后序遍历

层序遍历

#### 2022 统考真题 若结点p与q在二叉树T的中序遍历序列中相邻,且p在q之前,则下列p与q的关系中,不可能的是( )。

![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img408202203.png)

观察中序遍历  左根右    兄弟节点不会挨着的，选B。



## 三叉树

### 2022 统考真题 若三叉树T中有244个结点(叶结点的高度为1),则T的高度至少是()。

![image-20240916163632467](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916163632467.png)

C。

【解析】:推荐思路2

思路1：设度为k的树T有n个结点, T的最小高度为$log_k(n(k-1)+1)$,得到T的最小高度是6。

思路2： 完全三叉树，1+3+9+27+81<244,  还需要一层，



## 哈夫曼编码

#### 2022 统考真题 对任意给定的含n(n>2)个字符的有限集S,用二叉树表示S的哈夫曼编码集和定长编码集, 分别得到二叉树T1和T2。下列叙述中,正确的是()。

![image-20240916163919595](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916163919595.png)

【解析】：答案选D   送分题，搞清楚哈夫曼编码是什么就可以。

为什么要有**哈夫曼编码**？

通过根据字符出现的频率来分配不同长度的编码，达到数据压缩的目的。具体来说，对于出现频率较高的字符，分配较短的编码，而对于出现频率较低的字符，分配较长的编码。这样可以在整体上减少编码后的数据长度，从而提升传输和存储的效率。

**定长编码**是一种为每个字符或符号分配相同长度的二进制编码的方法。无论字符出现的频率高低，每个字符的编码长度都是一致的。定长编码的优点是简单且容易实现，编码和解码都非常直接。



## 图的连通性

> 图的一些基本概念
>
> 1. 数据结构中仅讨论简单图， 满足以下两个条件的称之为简单图 
>
>     a.  不存在重复边
>
>     b.   不存在顶点到自身的边
>
> 2.  无向图 |E| 的取值范围 为$0到\frac{n(n-1)}{2}$ 
>
> 3.  有$\frac{n(n-1)}{2}$ 条边的 无向图  是无向完全图
>
> 4.  有向图 |E| 的取值范围 为$n(n-1)$ ，有$n(n-1)$ 条边的 有向图  是有向完全图
>
> 5. 无向图有n个顶点， 如果边数小于$n-1$,那么此图是非连通图；
>
> 6. 非连通图至多有$\frac{(n-1)(n-2)}{2}$边, 考虑  一个 有着$n-1$顶点无向完全图，再加上一个孤立的点就是非连通图。
>
> 7. **强连通图（强连通分量）**: 在有向图中，若每对顶点 u 和 v 都存在从 u 到 v 的路径，并且从 v 到 u 也存在路径，则称该有向图是强连通的。换句话说，图中的任意两个顶点都可以通过有向边互相到达。
>
>    **强连通分量**: 是强连通图的一个子图，其中的每一对顶点之间都可以相互到达。每个有向图的强连通分量是其顶点集的一个子集，并且子图本身也是强连通的。整个图可以被分解为多个强连通分量。

### 2022 对于无向图G=(V,E),下列选项中,正确的是()。

![image-20240916171740341](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916171740341.png)

答案选 D，

A 选项，考虑：一个 有着$n-1$顶点无向完全图，再加上一个孤立的点就是非连通图，边数满足 |V|> |E| 同样可能非连通图

B 选项：  |V| <|E|     边为1，3个顶点，没有办法连通

C选项： 无向图构成一个环即可成为一个连通图

D选项，无向图有n个顶点， 如果边数小于$n-1$,那么此图是非连通图；

## AOE

## B树 B+树



### B 树的概念和性质

#### 什么是B 树

1. 多路平衡查找树，注意 B 树是平衡的，所有结点的平衡因子均等于0.
2. 树中每个结点至多有m棵子树，也就是说之多有m-1 个关键字。
3. **若根结点不是叶子结点，则至少有两棵子树**
4. 除根结点外的所有非叶结点至少有**$\lceil \frac{m}{2} \rceil$** 棵子树，也就是说  至少有$\lceil \frac{m}{2} \rceil-1$ 个关键字。
5. 所有的非叶子结点，其中的关键字K~i~，同一层内有序，满足$K_1 < K_2 < K_3<...<K_n$ 
6. 所有的叶子结点都在同一层次，并且不带任何信息，可以视为查找失败的结点。

#### B 树的高度

B树的高度，

最矮 ====》要使每个结点尽可能的满 》 每个结点最多有m棵子树，m-1 个关键字

$高度为m B树: n\leq (m-1)(1+m^2+m^3+...+m^{h-1} = m^h$-1

====> **$h\geq log_m (n+1)$**



最高 ====》要使每个结点关键字尽可能的少 》

让各层的分叉尽可能的少,即根节点只有2个分叉,其他结点只有[m/2]个分叉
各层结点至少有: 第一层 1、第二层 2、第三层$2\lceil \frac{m}{2} \rceil$…. 第h层$2\lceil \frac{m}{2} \rceil^{h-2}$
第h+1层共有叶子结点(失败结点) 第h+1层:$2\lceil \frac{m}{2} \rceil^{h-1}$个
n个关键字的B树必有n+1个叶子结点,则 $n+1 \geq 2\lceil \frac{m}{2} \rceil^{h-1}$

最后 **$h\leq log_{\lceil\frac{m}{2} \rceil}(\frac{n+1}{2})+1$**

### B 树的插入

**B 树（B-Tree）的插入**是一种保持树平衡的操作，它在插入新键时通过调整树的结构来维持其平衡和节点的容量约束。B 树是一种自平衡的多路搜索树，广泛应用于数据库和文件系统中，用来高效地存储和检索数据。

**B 树的基本性质：**

- 每个节点可以包含多个键。
- 每个内部节点有 k+1 个子节点（若有 k 个键）。
- 所有的叶节点在同一层，树始终保持平衡。
- 节点的键数有上下限（通常称为 **最小度数 t**），每个节点至少包含 t−1 个键，最多包含 2t−1 个键。

**B树的插入过程**

1. **从根节点开始**： 插入从根节点开始。沿着路径查找要插入的位置。根据要插入的键，找到合适的子节点递归进行插入，直到找到叶节点为止。
2. **节点不满的情况**： 如果要插入的叶节点不满（即包含少于 2t−1 个键），则直接将键插入该节点。插入完成。
3. **节点满的情况**： 如果叶节点满了（即已经有 2t−1 个键），则需要将节点分裂。分裂的步骤如下：
   1. 将满节点分成两个节点，每个节点包含 t−1 个键。
   2. 将中间键（第 t 个键）提升到父节点。
   3. 如果父节点也满了，则递归执行分裂操作，直到找到不满的父节点，或分裂一直递归到根节点。
4. **根节点分裂**： 如果根节点满了（包含 2t−1 个键），则根节点也会进行分裂。原来的根节点分裂为两个子节点，新的根节点只包含一个键（从旧根节点中间位置提升上来的键）。这会导致树的高度增加。

### B 树的删除

![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img1700656535900.png)

![image-20240916222554441](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916222554441.png)

### 2022 统考真题   在下图所示的5阶B树T中,删除关键字260之后需要进行必要的调整,得到新的B树T1。

### 下列选项中,不可能是T1根结点中关键字序列的是()。

#### ![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img408202208.png)

答案选D   90和110 之间只有一个100， 不满足B 树的定义，关键字个数小于2.



### B 树的删除  2012 统考 真题  9题

![image-20240921135527841](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240921135527841.png)

![image-20240921135601177](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240921135601177.png)

答案选D。



#### B 树 、B+ 树习题

![image-20240921145910107](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240921145910107.png)

![image-20240921145944596](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240921145944596.png)

## hash

比较简单，没什么意思。2024年 考大题，今年25肯定不会出大题。

## 排序

### 直接插入排序

### 希尔排序

### 简单选择排序

#### C++ 代码实现

```c++
void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n - 1; i++) {
        // 找到未排序部分的最小值
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 将最小值与未排序部分的第一个元素交换
        std::swap(arr[i], arr[minIndex]);
    }
}
```

#### 性能分析

**空间效率:**

仅使用常数个辅助单元,故空间效率为O(1)。

**时间效率:**

从上述伪码中不难看出,在简单选择排序过程中,元素移动的操作次数很少,不会超过3(n-1)次,最好的情况是移动0次,此时对应的表已经有序;但元素间比较的次数与序列的初始状态无关,始终是n(n-1)/2次,因此时间复杂度始终是O(n^2^)。

**稳定性:**

在第i趟找到最小元素后,和第i个元素交换,可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变。例如,表L={2,2,1},经过一趟排序后L={1,2,2},最终排
序序列也是L={1,2,2},显然,2与2的相对次序已发生变化。因此,简单选择排序是一种不稳定的排序方法。

### 堆排序

#### 堆的初始化

![1702343604147](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img1702343604147.png)

#### 堆 更新

分为输出堆顶元素和插入一个元素

![1699069540204](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimg1699069540204.png)



#### 习题

![image-20240921173913645](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240921173913645.png)

注意  15 跟17 题的差别！

### 归并排序

####  总结

![image-20240916235416786](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/imgimage-20240916235416786.png)

#### 代码实现

```c
int *B=(int *)malloc(n*sizeof(int));//辅助数组B

//A[low ... mid]和A[mid+1 ... high]各自有序,将两个部分归并
void Merge(int A[],int low, int mid, int high) 
{
    int i,j,k;
    for(k=low; k <= high; k++)
        B[k]=A[k];
    
    for(i=low,j=mid+1,k=i; i <= mid && j <= high; k++)
    {
        if(B[i] <= B[j])
            A[k]=B[i++];
        else
            A[k]=B[j++];
    }
	while(i <= mid)
    	A[k++]=B[i++];
    while(j <= high)
    	A[k++]=B[j++];

} 

void MergeSort(int A[],int low, int high) {
    if(low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid+1, high); //对右半部分归并排序
        Merge(A, low, mid, high);  //归并
    } 
}

```



### 基数排序

#### 性能分析

基数排序算法的性能分析如下。
**空间效率**:

一趟排序需要的辅助存储空间为r(r个队列:r个队头指针和r个队尾指针),但以后的排序中会重复使用这些队列,所以基数排序的空间复杂度为O(r)。
**时间效率:**

基数排序需要进行d趟分配和收集,一趟分配需要O(n),一趟收集需要O(r),所以基数排序的时间复杂度为O(d(n+r)),它与序列的初始状态无关。
**稳定性:**

对于基数排序算法而言,很重要一点就是按位排序时必须是稳定的。因此,这也保证了基数排序的稳定性。

### 快速排序

### 性能分析

快速排序算法的性能分析如下:
**空间效率:**

由于快速排序是递归的,需要借助一个递归工作栈来保存每层递归调用的必要信息,其容量与递归调用的最大深度一致。最好情况下为O(log~2~n);最坏情况下,因为要进行n-1次递归调用,所以栈的深度为O(n);平均情况下,栈的深度为O(log~2~ n)。
**时间效率:**

快速排序的运行时间与划分是否对称有关,快速排序的最坏情况发生在两个区域
分别包含n-1个元素和0个元素时,这种最大限度的不对称性若发生在每层递归上,即对应于初
始排序表基本有序或基本逆序时,就得到最坏情况下的时间复杂度为O(n^2^)。

有很多方法可以提高算法的效率:一种方法是尽量选取一个可以将数据中分的枢轴元素,如
从序列的头尾及中间选取三个元素,再取这三个元素的中间值作为最终的枢轴元素;或者随机地
从当前表中选取枢轴元素,这样做可使得最坏情况在实际排序中几乎不会发生。
在最理想的状态下,即Partition()可能做到最平衡的划分,得到的两个子问题的大小都
不可能大于n/2,在这种情况下,快速排序的运行速度将大大提升,此时,时间复杂度为O(nlog^2^ n)。
好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近,而不是接近其最坏情况
下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。
**稳定性**:

在划分算法中,若右端区间有两个关键字相同,且均小于基准值的记录,则在交换
到左端区间后,它们的相对位置会发生变化,即快速排序是一种不稳定的排序方法。例如,表L=
{3,**2**,2},经过一趟排序后L={2,**2**,3},最终排序序列也是L={2,2,3},显然,2与2的相对次
序已发生了变化。

**注意:**在快速排序算法中,并不产生有序子序列,但每趟排序后会将上一趟划分的各个无序
子表的枢轴(基准)元素放到其最终的位置上。

### 各种排序算法的性质

| 算法种类     | 最好情况时间复杂度 | 平均情况 时间复杂度 | 最坏情况 时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | ------------------ | ------------------- | ------------------- | ---------- | -------- |
| 直接插入     | O(n)               | O(n^2^)             | O(n^2^)             | O(1)       | 稳定     |
| 冒泡排序     | O(n)               | O(n^2^)             | O(n^2^)             | O(1)       | 稳定     |
| 简单选择排序 | O(n^2^)            | O(n^2^)             | O(n^2^)             | O(1)       | 不稳定   |
| 希尔排序     |                    |                     |                     | O(1)       | 不稳定   |
| 快速排序     | O(nlogn)           | O(nlogn)            | O(n^2^)             | O(nlogn)   | 不稳定   |
| 堆排序       | O(nlogn)           | O(nlogn)            | O(nlogn)            | O(1)       | 不稳定   |
| 二路归并排序 | O(nlogn)           | O(nlogn)            | O(nlogn)            | O(n)       | 稳定     |
| 基数排序     | O(d(n+r))          | O(d(n+r))           | O(d(n+r))           | O(r)       | 稳定     |

从时间复杂度看:

简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为O(n2),且实现过程也较为简单,但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到
O(n),

而简单选择排序则与序列的初始状态无关。

希尔排序作为插入排序的拓展,对较大规模的数据都可以达到很高的效率,但目前未得出其精确的渐近时间。

堆排序利用了一种称为堆的数据结构,可以在线性时间内完成建堆,且在O(nlog2n)内完成排序过程。

快速排序基于分治的思想,虽然最坏情况下的时间复杂度会达到O(n2),但快速排序的平均性能可以达到O(nlog2n),在实际应用中常常优于其他排序算法。

归并排序同样基于分治的思想,但由于其分割子序列与初始序列的排列无关,因此它的最好、最坏和平均时间复杂度均为O(nlog2n)。

从空间复杂度看:

简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数个辅助空间。

快速排序需要借助一个递归工作栈,平均大小为O(log2n),当然在最坏情况下可能会增长到O(n)。

2路归并排序在合并操作中需要借助较多的辅助空间用于元素复制,大小为O(n),虽然有方法能克服这个缺点,但其代价是算法会很复杂而且时间复杂度会增加。

从稳定性看:

插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法,

简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。

平均时间复杂度为O(nlog2n)的稳定排序算法只有归并排序,。

从过程特征看:

如冒泡排序和堆排序在每趟处理后都能产生当前的最大值或最小值,

而快速排序一趟处理至少能确定一个元素的最终位置等。



### 简单选择排序 VS 冒泡排序

**简单选择排序**和**冒泡排序**是两种经典的排序算法，尽管它们的时间复杂度都是 O(n^2^)，但它们的工作方式和实现细节有明显的不同。

### 1. **算法原理**

- **简单选择排序**：
  - 简单选择排序每次从未排序的部分中选出最小（或最大）的元素，放到已排序部分的末尾。
  - 具体步骤：
    1. 遍历整个数组，找到最小值（或最大值）。
    2. 将这个最小值与当前轮次的第一个元素交换。
    3. 然后从剩下的未排序部分中继续寻找最小值，重复此过程，直到排序完成。
  - 特点：在每一轮选择中，最多只进行一次交换。
- **冒泡排序**：
  - 冒泡排序是通过相邻元素的两两比较，将大的元素逐渐“冒泡”到数组的末尾。
  - 具体步骤：
    1. 从数组的开头开始，依次比较相邻的两个元素，如果前一个比后一个大，就交换它们。
    2. 每一轮比较之后，最大的元素会被移动到数组的最后。
    3. 不断缩小需要排序的部分，直到数组有序。
  - 特点：在每一轮比较中可能进行多次交换。

------

### 2. **比较与区别**

| **比较点**   | **简单选择排序**                                 | **冒泡排序**                                                 |
| ------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| **交换次数** | 最多 n−1 次交换，交换次数较少。                  | 每次比较都可能交换，最坏情况下，交换次数较多。               |
| **比较次数** | 总是比较 n(n−1)/2 次，不管数组是否有序。         | 在最好的情况下（数组已基本有序），比较次数可以减少。         |
| **稳定性**   | **不稳定**：相同元素的相对顺序可能被打乱。       | **稳定**：相同元素的相对顺序不会被改变。                     |
| **工作方式** | 每次选择一个最小（或最大）的元素，放到正确位置。 | 每次通过相邻元素比较和交换，将较大的元素逐步移动到末尾。     |
| **性能优化** | 没有内置的性能优化措施。                         | 可以通过标记（flag）来提前结束排序，当一轮比较后没有交换时即可结束。 |
| **适用场景** | 适用于需要减少交换次数的情况。                   | 适用于需要稳定排序的情况。                                   |





# 408 - 计算机组成原理

1. **CPI**（2014年12题） 执行一条指令所需要的时钟周期数 

​     1 GHz（即 10^9^ Hz）



2.  补码  的表示范围

   对于一个 **n 位**的补码数，表示的范围为：

   $$ [-2^{n-1}, 2^{n-1}-1]$$

3. IEEE 754

4.  主存容量的扩展

   ![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95.jpg)

4.  存储器与CPU的连接

   1. **合理选择存储芯片**
   要组成一个主存系统,选择存储芯片是第一步,主要指存储芯片的类型(RAM或 ROM)和数量的选择。通常选用ROM 存放系统程序、标准子程序和各类常数,RAM则是为用户编程而设置的。此外,在考虑芯片数量时,要尽量使连线简单、方便。
   2. 地址线的连接
   存储芯片的容量不同,其地址线数也不同,而CPU的地址线数往往比存储芯片的地址线数要多。**通常将CPU地址线的低位与存储芯片的地址线相连,以选择芯片中的某一单元(字选),**
   这部分的译码是由芯片的片内逻辑完成的。**而CPU地址线的高位则在扩充存储芯片时使用,用来选择存储芯片(片选),这部分译码由外接译码器逻辑完成。**
   例如,设CPU地址线为16位,即A~15~~ A~0~, 1Kx4位的存储芯片仅有10根地址线,此时可将CPU的低位地址A~9~~ A~0~与存储芯片的地址线A9~A0相连。
   3. 数据线的连接
   CPU 的数据线数与存储芯片的数据线数不一定相等,在相等时可直接相连;在不等时必须
   对存储芯片扩位,使其数据位数与CPU的数据线数相等。
   4. 读/写命令线的连接
   CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连,通常高电平为读,低电平为
   写。有些CPU的读/写命令线是分开的(读为RD,写为WE,均为低电平有效),此时CPU的
   读命令线应与存储芯片的允许读控制端相连,而CPU的写命令线则应与存储芯片的允许写控制
   端相连。
   5. 片选线的连接
   片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成,哪一片被
   选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。
   片选有效信号与CPU的访存控制信号MREQ(低电平有效)有关,因为只有当CPU要求
   访存时,才要求选中存储芯片。若CPU访问I/O,则MREQ为高,表示不要求存储器工作。

5.  指令集体系结构  ISA

   ISA规定的内容包括数据类型及格式,指令格式,寻址方式和可访问地址空间的大小,程序可访问的寄存器个数、位数和编号,控制寄存器的定义,IO空间的编址方式,中断结构,机器工作状态的定义和切换,输入输出结构和数据传送方式,存储保护方式等。不同时钟周期的CPU可以有相同的指令集。故本题选B。

6.   扩展操作码指令格式

   ![img](https://yian-1324200595.cos.ap-guangzhou.myqcloud.com/img%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-21%20192802.png)

# 408 - 操作系统

1. 文件系统初始化

2. 操作系统初始化

3. 银行家算法

4. 进程调度   抢占式

    注意P0的调度也算一次！

5. 用户态  内核态
6. 执行态、阻塞态、就绪态
7. 工作集
